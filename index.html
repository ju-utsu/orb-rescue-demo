<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Tomato VR — Orb Collector (Mobile WebVR)</title>
  <script src="https://unpkg.com/aframe@1.5.0/dist/aframe.min.js"></script>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #ui{position:fixed;left:12px;top:12px;z-index:20;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.8)}
    #score{font-size:20px;margin-bottom:6px}
    #controls{display:flex;gap:8px}
    .btn{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:8px 10px;border-radius:8px}
    #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,.7);color:#fff;padding:10px 14px;border-radius:10px;display:none;z-index:30}
    #mobile-controls{position:fixed;right:16px;bottom:18px;z-index:25;display:flex;gap:10px}
    .mob-btn{width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,.12);color:#fff}
    #title{font-weight:700;font-size:14px}
    #instructions{font-size:12px;opacity:.9}
    /* small hint for presentation */
    #credit{position:fixed;left:12px;bottom:12px;color:#fff;opacity:.8;font-size:12px}
  </style>
</head>
<body>
  <div id="ui">
    <div id="title">Tomato VR — Orb Collector</div>
    <div id="score">Score: <span id="scoreVal">0</span></div>
    <div id="controls">
      <button id="startBtn" class="btn">Start</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="leaderBtn" class="btn">Leaderboard</button>
    </div>
    <div id="instructions">Mobile: tilt/look to aim • Right side drag to turn • Left side tap to move forward</div>
  </div>
  <div id="toast"></div>
  <div id="credit">Team: 5 • Mobile-first WebVR • Host on GitHub Pages</div>
  <div id="mobile-controls" hidden>
    <button id="moveF" class="mob-btn">▲</button>
    <button id="moveB" class="mob-btn">▼</button>
  </div>

  <a-scene embedded background="color: #101216" vr-mode-ui="enabled: true">
    <!-- camera / player -->
    <a-entity id="player" position="0 1.6 0">
      <a-entity id="camera" camera look-controls wasd-controls="enabled: false"></a-entity>
      <a-entity id="hand-ray" raycaster="objects: .orb" line="color: #00ffcc"></a-entity>
    </a-entity>

    <!-- ground and sky -->
    <a-plane rotation="-90 0 0" width="200" height="200" color="#0a0a0f" material="shader: flat"></a-plane>
    <a-sky color="#0b1020"></a-sky>

    <!-- lighting -->
    <a-entity light="type: ambient; intensity:0.6"></a-entity>
    <a-entity light="type: point; intensity:1.2; distance:40" position="0 8 0"></a-entity>

    <!-- spawner entity; orbs will be generated by script -->
    <a-entity id="spawner"></a-entity>

    <!-- decorative stars -->
    <a-entity id="stars"></a-entity>

    <!-- scoreboard plane (visible in VR) -->
    <a-entity id="hud" position="0 2 -1.5">
      <a-plane width="1.2" height="0.5" color="#000" material="opacity:0.6"></a-plane>
      <a-text id="vr-score-text" value="Score: 0" align="center" position="0 0 0.01" color="#fff"></a-text>
    </a-entity>
  </a-scene>

  <script>
  // === Game settings ===
  const SETTINGS = {
    ORB_COUNT: 12,
    ORB_RESPAWN_INTERVAL: 1200, // ms
    GAME_DURATION: 60, // seconds
    ORB_RADIUS: 0.35,
    SPAWN_RADIUS: 6,
    COLLECTION_DISTANCE: 0.9
n  };

  // UI refs
  const scoreEl = document.getElementById('scoreVal');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const leaderBtn = document.getElementById('leaderBtn');
  const toast = document.getElementById('toast');
  const mobileControls = document.getElementById('mobile-controls');
  const moveF = document.getElementById('moveF');
  const moveB = document.getElementById('moveB');

  const scene = document.querySelector('a-scene');
  const player = document.getElementById('player');
  const cameraEl = document.getElementById('camera');
  const spawner = document.getElementById('spawner');

  // game state
  let score = 0;
  let gameRunning = false;
  let orbs = [];
  let timer = null;
  let timeLeft = SETTINGS.GAME_DURATION;

  // audio: small synthesized sound for pickup and background loop
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playPickup(){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    g.gain.value = 0.0001;
    o.connect(g);
    g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
    o.frequency.exponentialRampToValueAtTime(1320, now + 0.15);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
    o.start(now);
    o.stop(now + 0.36);
  }

  // simple background loop (very light) — play once user interacts
  let bgOsc;
  function startBg(){
    if (bgOsc) return;
    bgOsc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    bgOsc.type = 'triangle';
    bgOsc.frequency.value = 110;
    g.gain.value = 0.01;
    bgOsc.connect(g);
    g.connect(audioCtx.destination);
    bgOsc.start();
  }

  function showToast(txt, ms=1600){
    toast.textContent = txt; toast.style.display='block';
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>toast.style.display='none', ms);
  }

  // === Orb creation / behavior ===
  function spawnOrb(id){
    const angle = Math.random() * Math.PI * 2;
    const r = 1.6 + Math.random() * SETTINGS.SPAWN_RADIUS;
    const y = 1 + Math.random() * 2.2; // height
    const x = Math.cos(angle) * r;
    const z = Math.sin(angle) * r;

    const orb = document.createElement('a-entity');
    orb.setAttribute('class', 'orb');
    orb.setAttribute('position', `${x} ${y} ${z}`);
    orb.setAttribute('geometry', `primitive: sphere; radius: ${SETTINGS.ORB_RADIUS}`);
    orb.setAttribute('material', 'shader: standard; emissive: #00ffd6; metalness: 0.2; roughness: 0.3; color:#55ffee');
    orb.setAttribute('orb-behavior', `id:${id}`);
    spawner.appendChild(orb);
    orbs.push(orb);
  }

  AFRAME.registerComponent('orb-behavior', {
    schema: {id: {type:'int', default:0}},
    init: function(){
      this.pulse = 0;
    },
    tick: function(t, dt){
      // simple bob and pulse
      this.pulse += dt/1000;
      const y = 0.15 * Math.sin(this.pulse*2) + parseFloat(this.el.getAttribute('position').y);
      // don't permanently change base y — we'll keep it stored
      const pos = this.el.getAttribute('position');
      this.el.setAttribute('position', {x: pos.x, y: y, z: pos.z});

      // face the camera lightly via scale
      const camPos = cameraEl.object3D.position;
      const d = this.el.object3D.position.distanceTo(camPos);
      const s = Math.max(0.6, Math.min(1.4, 1.2 - (d-1)/8));
      this.el.setAttribute('scale', `${s} ${s} ${s}`);

      // check collection
      if (d < SETTINGS.COLLECTION_DISTANCE){
        collectOrb(this.el, this.data.id);
      }
    }
  });

  function clearOrbs(){
    orbs.forEach(o => o.parentNode && o.parentNode.removeChild(o));
    orbs = [];
  }

  function respawnOrbs(){
    clearOrbs();
    for(let i=0;i<SETTINGS.ORB_COUNT;i++) spawnOrb(i+1);
  }

  function collectOrb(el, id){
    // visual pop
    el.setAttribute('visible', false);
    playPickup();
    score += 1;
    updateScore();
    // add tiny explosion particle by creating small expanding sphere
    const p = document.createElement('a-sphere');
    p.setAttribute('position', el.getAttribute('position'));
    p.setAttribute('radius', '0.1');
    p.setAttribute('material','color:#fff;opacity:0.9');
    spawner.appendChild(p);
    // fade out
    setTimeout(()=>{p.parentNode && p.parentNode.removeChild(p)}, 450);

    // respawn after a tiny delay
    setTimeout(()=>{
      el.parentNode && el.parentNode.removeChild(el);
      orbs = orbs.filter(o => o !== el);
      setTimeout(()=> spawnOrb(id), 600 + Math.random()*1200);
    }, 120);
  }

  function updateScore(){
    scoreEl.textContent = score;
    const vrText = document.getElementById('vr-score-text');
    if (vrText) vrText.setAttribute('value', `Score: ${score}`);
  }

  // === Game flow ===
  function startGame(){
    if (!gameRunning){
      // resume audio context on user gesture
      if (audioCtx.state === 'suspended') audioCtx.resume();
      startBg();
      score = 0; updateScore();
      respawnOrbs();
      timeLeft = SETTINGS.GAME_DURATION;
      gameRunning = true;
      startBtn.textContent = 'Playing...';
      showToast('Game started — collect orbs!');
      // timer
      timer = setInterval(()=>{
        timeLeft -= 1;
        if (timeLeft <= 0){ endGame(); }
      }, 1000);
    }
  }
  function endGame(){
    gameRunning = false;
    clearInterval(timer);
    startBtn.textContent = 'Start';
    showToast(`Time up! Score: ${score}`);
    saveScore(score);
  }

  function resetGame(){
    gameRunning = false;
    clearInterval(timer);
    clearOrbs();
    score = 0; updateScore();
    startBtn.textContent = 'Start';
    showToast('Reset!');
  }

  startBtn.addEventListener('click', ()=>{
    startGame();
  });

  resetBtn.addEventListener('click', ()=>{
    resetGame();
  });

  leaderBtn.addEventListener('click', ()=>{
    showLeaderboard();
  });

  // === Leaderboard (localStorage) ===
  const LB_KEY = 'tomato_vr_lb_v1';
  function saveScore(s){
    const name = prompt('Enter name for leaderboard (short):','Player') || 'Player';
    const lb = JSON.parse(localStorage.getItem(LB_KEY) || '[]');
    lb.push({name: name.slice(0,16), score: s, date: new Date().toISOString()});
    lb.sort((a,b)=>b.score-a.score);
    localStorage.setItem(LB_KEY, JSON.stringify(lb.slice(0,10)));
    showToast('Saved to leaderboard');
  }

  function showLeaderboard(){
    const lb = JSON.parse(localStorage.getItem(LB_KEY) || '[]');
    if (lb.length === 0) return alert('No scores yet — play and save!');
    let msg = 'Leaderboard:\n';
    lb.forEach((r,i)=> msg += `${i+1}. ${r.name} — ${r.score}\n`);
    alert(msg);
  }

  // === Mobile controls (very simple forward/back) ===
  function enableMobileHUD(){
    mobileControls.hidden = false;
    moveF.addEventListener('touchstart', ()=> mobileMove(true));
    moveF.addEventListener('touchend', ()=> mobileStop());
    moveB.addEventListener('touchstart', ()=> mobileMove(false));
    moveB.addEventListener('touchend', ()=> mobileStop());
  }

  let movingInterval = null;
  function mobileMove(forward=true){
    if (movingInterval) return;
    movingInterval = setInterval(()=>{
      const dir = new THREE.Vector3();
      cameraEl.object3D.getWorldDirection(dir);
      dir.y = 0; dir.normalize();
      const mul = forward? 0.08 : -0.05;
      player.object3D.position.x += dir.x * mul;
      player.object3D.position.z += dir.z * mul;
    }, 40);
  }
  function mobileStop(){ clearInterval(movingInterval); movingInterval=null; }

  // show mobile HUD if touch
  window.addEventListener('touchstart', ()=>{ enableMobileHUD(); }, {once:true});

  // === stars decoration (cheap) ===
  function makeStars(){
    const starCount = 120;
    for(let i=0;i<starCount;i++){
      const s = document.createElement('a-sphere');
      const rx = (Math.random()-0.5)*90;
      const ry = 8 + Math.random()*40;
      const rz = (Math.random()-0.5)*90;
      s.setAttribute('position', `${rx} ${ry} ${rz}`);
      s.setAttribute('radius', `${0.02 + Math.random()*0.08}`);
      s.setAttribute('material', 'color: #fff; shader: flat; opacity: 0.9');
      document.getElementById('stars').appendChild(s);
    }
  }
  makeStars();

  // initial spawn so the preview looks alive
  respawnOrbs();

  // small helper: resume audio on first gesture
  document.body.addEventListener('click', ()=>{ if (audioCtx.state === 'suspended') audioCtx.resume(); startBg(); }, {once:true});

  // small accessibility: keyboard controls for desktop testing
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'r') resetGame();
    if (e.key === 's') startGame();
  });

  // save before unload
  window.addEventListener('beforeunload', ()=>{ localStorage.setItem(LB_KEY, localStorage.getItem(LB_KEY) || JSON.stringify([])); });

  </script>
</body>
</html>

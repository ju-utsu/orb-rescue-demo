<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Neon Grid â€” Orb Collector (Gaze + Score)</title>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/webxr/VRButton.js"></script>

<style>
  :root{ --neon:#00f0ff; --accent:#ff6b6b; --bg:#04060a; }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:var(--neon);overflow:hidden}
  /* Loader */
  #loader{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;z-index:40}
  .dot{width:14px;height:14px;margin:0 6px;background:var(--neon);border-radius:50%;animation:bounce .6s infinite alternate}
  .dot:nth-child(2){animation-delay:.12s}.dot:nth-child(3){animation-delay:.24s}
  @keyframes bounce{to{transform:translateY(-14px)}}

  /* Neon menu */
  #menu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:30;background:linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.9));backdrop-filter:blur(4px)}
  .menu-card{width:560px;padding:28px;border-radius:14px;border:1px solid rgba(0,255,240,0.12);box-shadow:0 12px 40px rgba(0,240,255,0.06);background:linear-gradient(180deg,#021020,#001318)}
  h1{margin:0 0 12px;font-family:Orbitron,system-ui;font-weight:700;color:var(--neon);text-shadow:0 0 18px rgba(0,240,255,0.18)}
  .row{display:flex;gap:12px;align-items:center;margin:10px 0}
  label{width:160px;color:#9ff; font-size:14px}
  select,input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,255,240,0.09);background:#00121a;color:var(--neon);font-size:14px}
  #startBtn{margin-top:16px;display:block;width:100%;padding:14px;border-radius:10px;border:2px solid var(--neon);background:transparent;color:var(--neon);font-weight:700;font-size:18px;cursor:pointer;box-shadow:0 0 18px rgba(0,240,255,0.05)}
  #startBtn:hover{background:var(--neon);color:#00131a}

  /* HUD */
  #hud{position:fixed;left:12px;top:12px;padding:8px 10px;border-radius:8px;background:rgba(0,0,0,0.5);z-index:20;font-weight:700}
  #hud small{display:block;font-weight:500;color:#aee;opacity:.9;font-size:12px}

  /* VR button placement */
  #vr-toggle{position:fixed;right:16px;top:12px;z-index:22;padding:8px 12px;border-radius:8px;border:none;background:var(--neon);color:#00131a;font-weight:700;cursor:pointer;display:none}

  /* Game Over */
  #gameover{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:35;background:rgba(0,0,0,0.75)}
  #gameover .card{background:#071018;padding:24px;border-radius:12px;border:1px solid rgba(255,80,80,0.08);color:#fff;text-align:center}
  button.small{margin-top:12px;padding:10px 18px;border-radius:8px;border:1px solid var(--neon);background:transparent;color:var(--neon);font-weight:700;cursor:pointer}
</style>
</head>
<body>

<!-- Loader -->
<div id="loader"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>

<!-- Neon Menu -->
<div id="menu" aria-hidden="true">
  <div class="menu-card">
    <h1>NEON ORB COLLECTOR</h1>

    <div class="row">
      <label>Difficulty</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>

    <div class="row">
      <label>Number of Orbs</label>
      <select id="orbCount">
        <option>5</option><option selected>10</option><option>15</option><option>25</option>
      </select>
    </div>

    <div class="row">
      <label>Number of Dangers</label>
      <select id="dangerCount">
        <option>2</option><option selected>5</option><option>8</option><option>12</option>
      </select>
    </div>

    <div class="row">
      <label>Gaze Dwell (ms)</label>
      <input id="gazeTime" type="number" min="200" step="50" value="800">
    </div>

    <div class="row">
      <label>Round Time (s)</label>
      <input id="roundTime" type="number" min="10" step="10" value="60">
    </div>

    <button id="startBtn">Start Game</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" aria-hidden="true">
  Score: <span id="score">0</span> &nbsp;|&nbsp; Time: <span id="timeLeft">60</span>s
  <small>(gaze to collect; avoid red)</small>
</div>

<!-- VR toggle -->
<button id="vr-toggle">Enter VR</button>

<!-- Game Over -->
<div id="gameover" role="dialog" aria-hidden="true">
  <div class="card">
    <div id="go-text" style="font-size:22px;font-weight:700;margin-bottom:8px">GAME OVER</div>
    <div id="finalScore" style="margin-bottom:12px">Score: 0</div>
    <button class="small" id="restartBtn">Restart</button>
  </div>
</div>

<!-- Three.js canvas will be injected here -->
<script>
/* ====== Setup & flow ====== */
const loaderEl = document.getElementById('loader');
const menuEl = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const hud = document.getElementById('hud');
const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('timeLeft');
const vrToggle = document.getElementById('vr-toggle');
const gameoverEl = document.getElementById('gameover');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

let renderer, scene, camera, controls;
let orbs = [], dangers = [], particles = [];
let raycaster, gazeTarget = null, gazeTimer = null, gazeStart = 0;
let score = 0;
let gameInterval = null;
let roundLeft = 60;
let running = false;
let gazeDwell = 800;

/* Show loader for brief moment then menu */
setTimeout(()=>{ loaderEl.style.display='none'; menuEl.style.display='flex'; menuEl.setAttribute('aria-hidden','false'); }, 900);

/* Start game from menu */
startBtn.addEventListener('click', startFromMenu);

function startFromMenu(){
  // read settings
  const orbCount = parseInt(document.getElementById('orbCount').value);
  const dangerCount = parseInt(document.getElementById('dangerCount').value);
  gazeDwell = Math.max(200, parseInt(document.getElementById('gazeTime').value) || 800);
  roundLeft = Math.max(10, parseInt(document.getElementById('roundTime').value) || 60);
  // hide menu, show HUD
  menuEl.style.display='none'; menuEl.setAttribute('aria-hidden','true');
  hud.style.display='block';
  hud.setAttribute('aria-hidden','false');
  vrToggle.style.display='inline-block';
  // init three scene
  initScene();
  // spawn objects (staggered)
  staggeredSpawn(orbCount, dangerCount);
  // reset game state
  score = 0; setScore(0);
  roundTimerStart(roundLeft);
  running = true;
}

/* ======= Three.js init ======= */
function initScene(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x02030a);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 8);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // VR button integration
  vrToggle.onclick = () => {
    document.body.appendChild(THREE.VRButton.createButton(renderer));
  }
  // allow entering VR via built-in button later

  // controls (orbit for normal mode)
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  // lights
  const hemi = new THREE.HemisphereLight(0x88e6ff, 0x080820, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0x00f0ff, 0.6);
  dir.position.set(5, 10, 2);
  scene.add(dir);

  // neon grid floor (glowing-ish)
  const gridMat = new THREE.LineBasicMaterial({ color: 0x00f0ff, transparent: true, opacity: 0.12 });
  const size = 80, divisions = 80;
  const grid = new THREE.GridHelper(size, divisions, 0x00f0ff, 0x00f0ff);
  grid.material.opacity = 0.08;
  grid.material.transparent = true;
  scene.add(grid);

  // raycaster
  raycaster = new THREE.Raycaster();

  // animate loop
  renderer.setAnimationLoop(animate);
}

/* ======= Spawning (staggered) ======= */
function staggeredSpawn(orbCount, dangerCount){
  // clear arrays if any
  orbs.forEach(o=>scene.remove(o)); dangers.forEach(d=>scene.remove(d));
  orbs = []; dangers = [];

  let spawnedOrbs = 0, spawnedDanger = 0;
  const orbInterval = setInterval(()=>{
    if(spawnedOrbs < orbCount){ spawnOrb(); spawnedOrbs++; } else clearInterval(orbInterval);
  }, 160);
  const dangerInterval = setInterval(()=>{
    if(spawnedDanger < dangerCount){ spawnDanger(); spawnedDanger++; } else clearInterval(dangerInterval);
  }, 420);
}

/* spawn functions */
function spawnOrb(){
  const g = new THREE.SphereGeometry(0.45, 16, 16);
  const m = new THREE.MeshStandardMaterial({ color:0x001a1f, emissive:0x00f0ff, emissiveIntensity:1.6, metalness:0.1, roughness:0.1 });
  const orb = new THREE.Mesh(g, m);
  const p = randomPos();
  orb.position.set(p.x, p.y, p.z);
  orb.userData.type = 'orb';
  scene.add(orb);
  orbs.push(orb);
  // gentle bob animation (store baseY)
  orb.userData.baseY = p.y;
  orb.userData.bobSpeed = 0.8 + Math.random()*0.8;
}

function spawnDanger(){
  const g = new THREE.BoxGeometry(0.6,0.6,0.6);
  const m = new THREE.MeshStandardMaterial({ color:0x200000, emissive:0xff4444, emissiveIntensity:1.5, metalness:0.1, roughness:0.2 });
  const box = new THREE.Mesh(g,m);
  const p = randomPos();
  box.position.set(p.x, Math.max(0.6,p.y-0.4), p.z);
  box.userData.type = 'danger';
  scene.add(box);
  dangers.push(box);
  box.userData.rotSpeed = 0.3 + Math.random()*0.7;
}

/* random position */
function randomPos(){
  const r = 3 + Math.random()*10;
  const a = Math.random()*Math.PI*2;
  const y = 0.8 + Math.random()*2.2;
  return { x: Math.cos(a)*r, y, z: Math.sin(a)*r };
}

/* ======= Animation & Gaze logic ======= */
let lastTime = performance.now();
function animate(time){
  const dt = (time - lastTime)/1000;
  lastTime = time;

  // update bobbing
  orbs.forEach(o=>{
    o.position.y = o.userData.baseY + Math.sin(time*0.002*o.userData.bobSpeed)*0.25;
  });
  // rotate dangers
  dangers.forEach(d=>{
    d.rotation.y += (d.userData.rotSpeed || 0.4)*dt;
  });

  // gaze / raycast from camera center
  // cast ray from camera forward
  raycaster.setFromCamera({x:0, y:0}, camera); // center of screen
  const hits = raycaster.intersectObjects([...orbs, ...dangers], false);
  if(hits && hits.length > 0){
    const hit = hits[0].object;
    if(gazeTarget !== hit){
      // new target
      clearGaze();
      gazeTarget = hit;
      gazeStart = performance.now();
      // start visual indicator (scale up slightly)
      hit.scale.set(1.08,1.08,1.08);
    } else {
      // same target, check dwell
      const elapsed = performance.now() - gazeStart;
      const required = (hit.userData.type === 'orb') ? gazeDwell : Math.max(gazeDwell, 400);
      // small visual progress (pulse)
      const t = Math.min(1, elapsed/required);
      hit.material.emissiveIntensity = 1.6 + t*2.0;
      if(elapsed >= required){
        // trigger action
        if(hit.userData.type === 'orb'){
          collectOrb(hit);
        } else if(hit.userData.type === 'danger'){
          // death
          gameOver('Gazed at danger');
        }
        clearGaze();
      }
    }
  } else {
    clearGaze();
  }

  // render
  controls.update();
  renderer.render(scene, camera);
}

/* clear gaze visuals and timer */
function clearGaze(){
  if(gazeTarget){
    // reset visuals
    gazeTarget.scale.set(1,1,1);
    if(gazeTarget.material) gazeTarget.material.emissiveIntensity = (gazeTarget.userData.type === 'orb') ? 1.6 : 1.5;
  }
  gazeTarget = null;
  gazeStart = 0;
}

/* click fallback: click to collect / trigger */
window.addEventListener('pointerdown', (e)=>{
  if(!running) return;
  // compute ray from pointer click
  const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, - (e.clientY / window.innerHeight) * 2 + 1);
  const rc = new THREE.Raycaster(); rc.setFromCamera(mouse, camera);
  const hit = rc.intersectObjects([...orbs, ...dangers], false)[0];
  if(hit){
    const obj = hit.object;
    if(obj.userData.type === 'orb') collectOrb(obj);
    else if(obj.userData.type === 'danger') gameOver('Clicked danger');
  }
});

/* collect orb */
function collectOrb(obj){
  // particle burst
  const pos = obj.position.clone();
  doParticleBurst(pos);
  // play sound (optional)
  // remove object
  scene.remove(obj);
  orbs = orbs.filter(o => o !== obj);
  // increment score
  score += 10;
  setScore(score);
}

/* particle burst simple */
function doParticleBurst(pos){
  for(let i=0;i<10;i++){
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.06,8,8), new THREE.MeshBasicMaterial({color:0xffffff}));
    s.position.set(pos.x, pos.y, pos.z);
    scene.add(s);
    // animate outward
    const vx = (Math.random()-0.5)*1.2, vy = Math.random()*1.4, vz = (Math.random()-0.5)*1.2;
    const dur = 400 + Math.random()*300;
    const start = performance.now();
    (function animParticle(p, sx, sy, sz){
      function step(t){
        const tt = (t - start)/dur;
        if(tt >= 1){ scene.remove(p); return; }
        p.position.x = pos.x + vx * tt * 1.6;
        p.position.y = pos.y + vy * tt;
        p.position.z = pos.z + vz * tt * 1.6;
        p.material.opacity = 1 - tt;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    })(s);
  }
}

/* score UI update */
function setScore(v){ scoreEl.textContent = v; }

/* round timer */
function roundTimerStart(seconds){
  roundLeft = seconds;
  timeEl.textContent = roundLeft;
  if(gameInterval) clearInterval(gameInterval);
  gameInterval = setInterval(()=>{
    if(!running) return;
    roundLeft -= 1;
    timeEl.textContent = roundLeft;
    if(roundLeft <= 0){ clearInterval(gameInterval); gameOver(\"Time's up\"); }
  }, 1000);
}

/* game over */
function gameOver(reason){
  running = false;
  showGameOver(reason);
}

/* show game over overlay */
function showGameOver(reason){
  finalScoreEl.textContent = 'Score: ' + score;
  document.getElementById('go-text').textContent = reason;
  gameoverEl.style.display = 'flex';
  gameoverEl.setAttribute('aria-hidden','false');
}

/* restart button */
restartBtn.addEventListener('click', ()=>{
  // remove renderer and canvas
  if(renderer){ renderer.setAnimationLoop(null); renderer.domElement && renderer.domElement.remove(); renderer.dispose && renderer.dispose(); }
  // reset arrays
  orbs = []; dangers = []; particles = [];
  // hide overlays
  gameoverEl.style.display='none';
  hud.style.display='none';
  // bring menu back
  menuEl.style.display='flex';
  menuEl.setAttribute('aria-hidden','false');
  running = false;
});

/* utilities */
window.addEventListener('resize', ()=>{
  if(renderer && camera){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
});

</script>
</body>
  </html>
